% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/dCVnet_utilities.R
\name{amalgamate_cv.glmnet}
\alias{amalgamate_cv.glmnet}
\title{amalgamate_cv.glmnet}
\usage{
amalgamate_cv.glmnet(cvglmlist, checks = list(alpha = TRUE, lambda =
  TRUE, type.measure = TRUE))
}
\arguments{
\item{cvglmlist}{a list of cv.glmnet models}

\item{checks}{should any checks be suppressed (typically not)}
}
\value{
an object of class \code{"cv.glmnet"} is returned, which is a
  list with the ingredients of the cross-validation fit.
  \item{lambda}{the values of \code{lambda} used in the fits.}
  \item{cvm}{The mean cross-validated error - a vector of length
    \code{length(lambda)}.}
  \item{cvsd}{estimate of standard error of \code{cvm}.}
  \item{cvup}{upper curve = \code{cvm+cvsd}.}
  \item{cvlo}{lower curve = \code{cvm-cvsd}.}
  \item{nzero}{number of non-zero coefficients at each \code{lambda}.}
  \item{name}{a text string indicating type of measure (for plotting
    purposes).}
 \item{glmnet.fit}{a fitted glmnet object for the full data.}
  \item{lambda.min}{value of \code{lambda} that gives minimum
    \code{cvm}.}
  \item{lambda.1se}{largest value of \code{lambda} such that error is
    within 1 standard error of the minimum.}
  \item{fit.preval}{if \code{keep=TRUE}, this is the array of
    prevalidated fits. Some entries can be \code{NA}, if that and
    subsequent values of \code{lambda} are not reached for that fold}
  \item{foldid}{if \code{keep=TRUE}, the fold assignments used}
}
\description{
Gathers results from a list of \code{\link[glmnet]{cv.glmnet}} objects
and returns a merged, averaged object.
}
\details{
The arithmetic mean k-fold cross-validated loss (i.e. type.measure) is taken
over the models (with the sd averaged via variance).
The cv SE upper and lower limits (used in lambda.1se calculation) are then
calculated from on the averaged data and finally the cv optimal lambda.1se
and lambda.min values calculated for the averaged performance.

Consistent with cv.glmnet, the model coefficients within folds are not
made available, averaged or otherwise investigable, but a whole data model
is returned in the \code{glmnet.fit} slot.

The cvglmlist must contain cv.glmnet models suitable for averaging together.
This typically means all models having the same:
\itemize{
\item{family}
\item{x and y data}
\item{alpha value}
\item{lambda sequence}
\item{type.measure}
\item{number of k-fold CV folds}
\item{other cv.glmnet options}
}
in order for the amalgamated results to "make sense".
Essentially the models in the list should only differ on the random
allocation of folds to cases (usually specified in foldid).

Some limited checks are implemented to ensure alpha, lambda and type.measure
are identical. There is an option to turn these checks off, but this is
not recommended.

This function presently does not honour the "keep" argument of cv.glmnet and
all additional arrays/vectors are silently dropped.
}
\examples{
\dontrun{
data("CoxExample", package = "glmnet") # x and y
# folds for unstratified 10x-repeated 5-fold cv:
foldlist <- replicate(10,
sample(1:5, size = NROW(x), replace = TRUE),
simplify = FALSE)
names(foldlist) <- paste0("Rep", 1:10) # label the replications.
lambdaseq <- glmnet::cv.glmnet(x=x, y=y, family = "cox")$lambda
# create a list of models:
modellist <- lapply(foldlist, function(ff) {
glmnet::cv.glmnet(x = x, y = y, family = "cox", foldid = ff, lambda = lambdaseq) } )

# use amalgamate to average results:
mod <- amalgamate_cv.glmnet(modellist)

# compare rep-rep performance variability with the average performance:
# rep1:
glmnet::plot.cv.glmnet(modellist[[1]], main = "rep1")
# rep2:
glmnet::plot.cv.glmnet(modellist[[2]], main = "rep2")
# etc...
# mean:
glmnet::plot.cv.glmnet(mod, main = "averaged")
}
}
\seealso{
\code{\link[glmnet]{cv.glmnet}}
}
