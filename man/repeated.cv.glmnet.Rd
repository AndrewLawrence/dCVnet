% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/dCVnet_innerloop.R
\name{repeated.cv.glmnet}
\alias{repeated.cv.glmnet}
\title{repeated.cv.glmnet}
\usage{
repeated.cv.glmnet(x, y, folds, lambdas, alpha, family,
  opt.lambda.type = "minimum", opt.lambda.type.value = 1, ...,
  debug = FALSE)
}
\arguments{
\item{x}{input matrix, of dimension nobs x nvars; each row is an
  observation vector. Can be in sparse matrix format (inherit from class \code{"sparseMatrix"} as in package \code{Matrix}; not yet available for \code{family="cox"})}

\item{y}{response variable. Quantitative for \code{family="gaussian"},
  or \code{family="poisson"} (non-negative counts). For
  \code{family="binomial"} should be either a factor with two levels, or
  a two-column matrix of counts or proportions (the second column is
  treated as the target class; for a factor, the last level in
  alphabetical order is the target class). For
  \code{family="multinomial"}, can be a \code{nc>=2} level factor, or a
  matrix with \code{nc} columns of counts or proportions.
  For either \code{"binomial"} or \code{"multinomial"}, if \code{y} is
  presented as a vector, it will be coerced into a factor. For
  \code{family="cox"}, \code{y} should be a two-column matrix with
  columns named 'time' and 'status'. The latter is a binary variable,
  with '1' indicating death, and '0' indicating right censored. The
  function \code{Surv()} in package \pkg{survival} produces such a
  matrix. For  \code{family="mgaussian"}, \code{y} is a matrix of quantitative responses.}

\item{folds}{This is a list where each element is an integer vector
of length \emph{n_cases}. The integer for each case labels it as belonging
to a fold \emph{1:n_folds}. This argument implicitly sets the number of repeats
and the k in repeated k-fold cv.}

\item{lambdas}{use a fixed, user supplied lambda sequence (descending)
see \code{\link[glmnet]{glmnet}}}

\item{alpha}{The elasticnet mixing parameter, with
    \eqn{0\le\alpha\le 1}. The penalty is defined
    as \deqn{(1-\alpha)/2||\beta||_2^2+\alpha||\beta||_1.} \code{alpha=1}
    is the lasso penalty, and \code{alpha=0} the ridge penalty.}

\item{family}{Response type (see above)}

\item{opt.lambda.type}{Method for selecting optimum lambda. One of
\itemize{
\item{\code{"minimum"} - returns the lambda with best
CV score.}
\item{\code{"se"} - returns the +1 se lambda}
\item{\code{"percentage"} - returns minimum lambda
scaled by a factor, e.g. allowing lambda+3pc}
}}

\item{opt.lambda.type.value}{determines the se multiplier or percentage
for \code{opt.lambda.type}.}

\item{...}{arguments passed to \code{\link[glmnet]{cv.glmnet}}}

\item{debug}{if TRUE return models and unaveraged results (default: FALSE).}
}
\value{
a data.frame object of class \code{\link{repeated.cv.glmnet}}
containting averaged metrics. Has the following columns:
\itemize{
\item{lambda - lambda at which performance evaluated}
\item{cvm - average performance metric}
\item{cvsd - average sd of performance metric}
\item{cvup - average cvm + cvsd}
\item{cvlo - average cvm - cvsd}
\item{nzero - average number of nonzero predictors}
\item{lambda.min - logical indicating 'best' performing lambda
(see opt.lambda.type and opt.lambda.type.value)}
}
Also contains attributes for the response family (\code{family})
and cv-type (\code{type.measure})
}
\description{
Repeatedly runs a \code{\link[glmnet]{cv.glmnet}} and returns averaged
results. \emph{This is intended as a dCVnet internal function}.
}
\details{
The code will run for any glmnet family, but folds & lambdas must be
correctly specified.
}
