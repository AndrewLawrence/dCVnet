---
title: "Merging and Manipulating ROC plots"
output: rmarkdown::html_vignette
vignette: >
  %\VignetteIndexEntry{Merging and Manipulating ROC plots}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

```{r, include = FALSE}
knitr::opts_chunk$set(
collapse = TRUE,
comment = "#>"
)
```

***THIS VIGNETTE IS CURRENTLY WORK IN PROGRESS***

This example will demonstrate:

 * plotting a ROC curve for dCVnet
 * ROC plots showing data from different dCVnet models.
 * ROC plot customisation

First, setup the R environment and make some example dCVnet objects:

```{r setup}
knitr::opts_chunk$set(
	echo = FALSE,
	message = FALSE,
	warning = FALSE
)
library(tidyverse)
ggplot2::theme_set(theme_minimal())
library(dCVnet)
data(prostate, package = "dCVnet")

prostate$agecat <- factor(prostate$age > 65, levels = c(FALSE, TRUE), labels = c("le65", "over65"))

set.seed(42)

# Model 1 predicts SVI (seminal vesicle invasion):
mod1 <- dCVnet::dCVnet(y = prostate$svi,
                       data = prostate %>% select(-train, -svi),
                       nrep_outer = 3, k_outer = 3, nrep_inner = 1, k_inner = 10)

# Model 2 predicts whether Age > 65:
mod2 <- dCVnet::dCVnet(y = prostate$agecat,
                       data = prostate %>% select(-train, -age, -agecat),
                       nrep_outer = 3, k_outer = 3, nrep_inner = 1, k_inner = 10)

```

# The default ROC plot
By default, calling `plot(my_dCVnet, type = "ROC")` on a dCVnet object
produces a plot of the cross-validated ROCs over the different outer loop 
repetitions (to show the variability).

Under the hood this function is composing three steps:

 1. getting performance information from the outer-loop cross-validation (using `dCVnet::performance`)
 2. extracting sensitivity, specificity and threholds and turning this into a 
      standardised *rocdata* format using `dCVnet::extract_rocdata`
 3. running the plot method for rocdata objects (`plot.rocdata`).



```{r default plot, echo=TRUE, fig.height=7, fig.width=7}
p1 <- plot(mod1, type = "ROC")

# Note this is identical to:
# p1 <- plot(extract_rocdata(dCVnet::performance(mod1)))

```

# Plots with averaged ROC
To plot overall (average) cross-validated ROC taken over the repetitions of the
repeated k-fold outer-loop cross-validation, use `dCVnet::average_rocdata()` on
the *rocdata* object.

```{r average plot, echo=TRUE, fig.height=7, fig.width=7}
p2 <- plot(average_rocdata(extract_rocdata(performance(mod1))))

# This nested function is more readable if you use the piping function (%>%):
#   p2 <- mod1 %>% 
#           performance %>% 
#           extract_rocdata %>% 
#           average_rocdata %>% 
#           plot()

```

# Combining average and CV-variability
Perhaps we want to see both the average performance and its variability over 
outerloop-cv repetitions. We can combine two rocdata objects with rbind
(they are really just data.frames with particular columns):

```{r combined plot, echo=TRUE, fig.height=7, fig.width=7}
combined_roc_data <- rbind(extract_rocdata(performance(mod1)),
                           average_rocdata(extract_rocdata(performance(mod1))))
p3 <- plot(combined_roc_data)

# Written (paritally) using pipes:
#   p3 <- rbind(mod1 %>% 
#                 performance() %>% 
#                 extract_rocdata(),
#               mod1 %>% 
#                 performance() %>% 
#                 extract_rocdata() %>% 
#                 average_rocdata())


```

# Plotting from multiple models
Sometimes we want to display the results from two or more models
in the same ROC plot. Do this by `rbind`-ing the separate rocdata objects.
However, we first need to give informative names in the run column:

```{r multimodel plot, echo=TRUE, fig.height=7, fig.width=7}
d1 <- mod1 %>% 
  performance() %>% 
  extract_rocdata() %>% 
  average_rocdata() %>% 
  mutate(run = "Model 1") # labels the data from this model.

d2 <- mod2 %>% 
  performance() %>% 
  extract_rocdata() %>% 
  average_rocdata() %>% 
  mutate(run = "Model 2") # labels the data from this model

p4 <- plot(rbind(d1, d2))


```

Looking at `?plot.dCVnet` we can see that this is a call to `dCVnet::plot.rocdata`
From `?plot.rocdata` we see that this method uses a "rocdata" object which is
generated by `dCVnet::extract_rocdata`.

# Plot options

As set out below, most customisation is done via ggplot, but there are two 
options for plot customisation in `plot.rocdata`. The legend can be toggled off
with `legend = FALSE`, and the threshold labels can be altered
(`alphalabel = c(0.05, 0.5, 0.95)`) or omitted (`alphalabel = FALSE`).

```{r options1, echo=TRUE, fig.height=7, fig.width=7}

# Make a version of p4 without a legend, and no markers for threshold:
p5 <- plot(rbind(d1, d2), alphalabel = FALSE, legend = FALSE)


```

# Customising plots

dCVnet ROC plots are ggplot2 objects, so quite a few manipuations can be done
without recalculating the plot. In the following example I will modify `p5` the 
multiple-models plot to...

 1. Add a plot title
 2. Change the legend headings
 3. Manually set colours
 4. Change the plot appearance with a different ggplot theme

```{r options2, echo=TRUE, fig.height=7, fig.width=7}

p4$plot +
  scale_colour_manual(values = c(`Model 2` = "goldenrod",
                                 `Model 1` = "cadetblue")) +
  labs(title = "Model Comparison",
       colour = "Prediction\nModel",
       shape = "Thresh.") +
  theme_classic() 

```

# Further Customisation

Somes changes are not easy to make in ggplot after the plot has been generated.
Things like remapping aesthetics.

If you need a lot of control over the display, or would prefer a base R plot
rather than ggplot, the underlying data are returned by the call to 
`plot.rocdata`.

```{r plotdata}

head(p4$data)

```


